# 医保接口协议详细技术规范文档

## 一、协议总览

### 1.1 协议基础信息
- **通信协议**: HTTP/HTTPS POST
- **数据格式**: JSON
- **字符编码**: UTF-8
- **认证方式**: AK/SK + HmacSHA1签名
- **时间戳**: 13位毫秒时间戳
- **超时机制**: 签名时间戳超时30分钟

### 1.2 接口分类
```
医保接口分类：
├── 查询类接口
│   ├── 1101 - 人员信息获取
│   ├── 1102 - 其他查询接口
│   └── ...
├── 目录下载类接口  
│   ├── 1301 - 西药中成药目录下载
│   ├── 1302 - 中药目录下载
│   ├── 1303 - 诊疗项目目录下载
│   └── 1304-1319 - 其他目录下载
├── 数据上传类接口
│   ├── 4701 - 电子病历上传
│   └── 其他业务上传接口
└── 文件传输接口
    ├── 9101 - 文件上传
    └── 9102 - 文件下载
```

## 二、报文格式规范

### 2.1 标准输入报文格式

#### 2.1.1 报文结构
```json
{
  "infno": "1101",                    // 交易编号(4位)
  "msgid": "H43111100255202507141030154001", // 报文ID(30位)
  "mdtrtarea_admvs": "431199",        // 就医地医保区划(6位)
  "insuplc_admdvs": "431199",         // 参保地医保区划(6位)
  "recer_sys_code": "99",             // 接收方系统代码(10位)
  "dev_no": "null",                   // 设备编号(100位,可空)
  "dev_safe_info": "null",            // 设备安全信息(2000位,可空)
  "cainfo": "null",                   // 数字签名信息(1024位,可空)
  "signtype": "SM2",                  // 签名类型(10位,建议SM2/SM3)
  "infver": "1.0.0",                  // 接口版本号(6位)
  "opter_type": "1",                  // 经办人类别(3位) 1-经办人;2-自助终端;3-移动终端
  "opter": "0153",                    // 经办人(30位)
  "opter_name": "系统管理员",          // 经办人姓名(50位)
  "inf_time": "2025-07-14 10:30:15",  // 交易时间(19位)
  "fixmedins_code": "H43111100255",   // 定点医药机构编号(12位)
  "fixmedins_name": "某某医院",        // 定点医药机构名称(20位)
  "sign_no": "null",                  // 交易签到流水号(30位,可空)
  "input": {                          // 交易输入(40000位)
    // 具体业务数据，根据不同接口而定
  }
}
```

#### 2.1.2 字段详细说明

| 字段名 | 类型 | 长度 | 必填 | 说明 |
|--------|------|------|------|------|
| infno | 字符型 | 4 | Y | 交易编号，如：1101、1301、9101等 |
| msgid | 字符型 | 30 | Y | 报文ID格式：机构编号(12)+时间(14)+序号(4) |
| mdtrtarea_admvs | 字符型 | 6 | Y | 就医地医保区划代码 |
| insuplc_admdvs | 字符型 | 6 | N | 参保地医保区划，异地就医必填 |
| recer_sys_code | 字符型 | 10 | Y | 接收方系统代码，固定"99" |
| dev_no | 字符型 | 100 | N | 设备编号，可传"null" |
| dev_safe_info | 字符型 | 2000 | N | 设备安全信息，可传"null" |
| cainfo | 字符型 | 1024 | N | 数字签名信息，可传"null" |
| signtype | 字符型 | 10 | N | 签名类型，建议"SM2" |
| infver | 字符型 | 6 | Y | 接口版本号，如"1.0.0" |
| opter_type | 字符型 | 3 | Y | 经办人类别：1-经办人；2-自助终端；3-移动终端 |
| opter | 字符型 | 30 | Y | 经办人代码 |
| opter_name | 字符型 | 50 | Y | 经办人姓名 |
| inf_time | 日期时间型 | 19 | Y | 交易时间，格式：yyyy-MM-dd HH:mm:ss |
| fixmedins_code | 字符型 | 12 | Y | 定点医药机构编号 |
| fixmedins_name | 字符型 | 20 | Y | 定点医药机构名称 |
| sign_no | 字符型 | 30 | N | 交易签到流水号，可传"null" |
| input | 字符型 | 40000 | Y | 交易输入数据，JSON格式 |

### 2.2 标准输出报文格式

#### 2.2.1 成功响应格式
```json
{
  "infcode": 0,                             // 交易状态码：0-成功，-1-失败
  "inf_refmsgid": "430000002507141030120130589177", // 接收方报文ID(30位)
  "refmsg_time": "20250714103012469",       // 接收报文时间(17位)
  "respond_time": "20250714103012469",      // 响应报文时间(17位)
  "err_msg": "",                            // 错误信息(200位)
  "output": {                               // 交易输出(40000位)
    // 具体业务返回数据
  },
  "warn_msg": "成功",                       // 警告信息
  "cainfo": "",                             // CA信息
  "signtype": ""                            // 签名类型
}
```

#### 2.2.2 失败响应格式
```json
{
  "infcode": -1,
  "inf_refmsgid": null,
  "refmsg_time": null,
  "respond_time": null,
  "err_msg": "MBS-cn.hsa.ais.common.exception.HygeiaException: 请求失败,错误原因：本地查询错误:该参保人的基本信息为空null",
  "output": null,
  "warn_msg": null,
  "cainfo": "",
  "signtype": ""
}
```

#### 2.2.3 输出字段说明

| 字段名 | 类型 | 长度 | 非空 | 说明 |
|--------|------|------|------|------|
| infcode | 数值型 | 4 | Y | 交易状态码：0-成功，-1-失败 |
| inf_refmsgid | 字符型 | 30 | Y | 接收方报文ID：区划代码(6)+时间(14)+流水号(10) |
| refmsg_time | 字符型 | 17 | N | 接收报文时间：yyyyMMddHHmmssSSS |
| respond_time | 字符型 | 17 | N | 响应报文时间：yyyyMMddHHmmssSSS |
| err_msg | 字符型 | 200 | N | 错误信息，失败时返回具体错误描述 |
| output | 字符型 | 40000 | N | 交易输出数据，JSON格式 |

## 三、服务网关认证协议

### 3.1 网关请求头规范

#### 3.1.1 必需请求头
```http
POST /fsi/api/rsfComIfsService/callService HTTP/1.1
Host: dms.hun.hsip.gov.cn
Content-Type: text/plain; charset=utf-8
_api_name: 1101
_api_version: 1.0.0
_api_timestamp: 1721789415123
_api_access_key: yRV6rnHYEa2clmx1MCWb4HjlOcwhS8gLbW6O4o
_api_signature: ABCD1234567890EFGH==
```

#### 3.1.2 请求头字段说明

| 字段名 | 类型 | 长度 | 必填 | 说明 |
|--------|------|------|------|------|
| _api_name | 字符型 | 100 | Y | 接口名，如：1101、1301、9101 |
| _api_version | 字符型 | 100 | Y | 版本号，固定：1.0.0 |
| _api_timestamp | 时间戳 | - | Y | 13位毫秒时间戳 |
| _api_access_key | 字符型 | 100 | Y | AK密钥，由医保局提供 |
| _api_signature | 字符型 | 300 | Y | 签名，使用SK生成 |

### 3.2 签名生成算法

#### 3.2.1 签名算法详细步骤
```python
def generate_signature(api_name: str, api_version: str, timestamp: int, ak: str, sk: str) -> str:
    """
    生成医保接口签名
    
    步骤：
    1. 构建参数字典并按key排序
    2. 拼接key=value&格式字符串
    3. 使用SK进行HmacSHA1签名
    4. Base64编码签名结果
    """
    # 1. 构建参数字典
    params = {
        '_api_access_key': ak,
        '_api_name': api_name,
        '_api_timestamp': str(timestamp),
        '_api_version': api_version
    }
    
    # 2. 按key自然排序并拼接
    sign_string = '&'.join([f"{k}={v}" for k, v in sorted(params.items())])
    # 结果示例：_api_access_key=xxx&_api_name=1101&_api_timestamp=1721789415123&_api_version=1.0.0
    
    # 3. HmacSHA1签名
    import hmac
    import hashlib
    import base64
    
    signature = hmac.new(
        sk.encode('utf-8'),
        sign_string.encode('utf-8'),
        hashlib.sha1
    ).digest()
    
    # 4. Base64编码
    return base64.b64encode(signature).decode('utf-8')
```

#### 3.2.2 签名验证流程
```python
def verify_signature(api_name: str, api_version: str, timestamp: int, ak: str, sk: str, provided_signature: str) -> bool:
    """验证签名是否正确"""
    expected_signature = generate_signature(api_name, api_version, timestamp, ak, sk)
    return expected_signature == provided_signature

def check_timestamp_validity(timestamp: int, max_age_minutes: int = 30) -> bool:
    """检查时间戳是否在有效期内"""
    import time
    current_timestamp = int(time.time() * 1000)
    time_diff_minutes = (current_timestamp - timestamp) / (1000 * 60)
    return time_diff_minutes <= max_age_minutes
```

### 3.3 网关错误响应

#### 3.3.1 认证错误类型
```json
// 1. 缺少请求头
{
  "code": 401,
  "message": "缺少服务网关的请求头!"
}

// 2. 时间戳超时
{
  "code": 401,
  "message": "签名时间戳超时!"
}

// 3. 非法用户
{
  "code": 401,
  "message": "非法用户!"
}

// 4. 签名不一致
{
  "code": 401,
  "message": "签名不一致!"
}
```

#### 3.3.2 错误处理策略
```python
class GatewayErrorHandler:
    @staticmethod
    def handle_gateway_error(response_code: int, message: str):
        if response_code == 401:
            if "缺少服务网关的请求头" in message:
                raise MissingHeadersError("请求头不完整，请检查_api_*字段")
            elif "签名时间戳超时" in message:
                raise TimestampExpiredError("签名时间戳超时，请重新生成")
            elif "非法用户" in message:
                raise InvalidUserError("AK密钥无效，请检查配置")
            elif "签名不一致" in message:
                raise SignatureError("签名验证失败，请检查SK密钥和签名算法")
        
        raise UnknownGatewayError(f"网关错误: {message}")
```

## 四、具体接口协议

### 4.1 人员信息获取接口 (1101)

#### 4.1.1 接口用途
通过身份证号、社保卡号或电子凭证获取参保人的基本信息、参保状态和身份信息。

#### 4.1.2 输入参数 (节点标识：data)
```json
{
  "input": {
    "data": {
      "mdtrt_cert_type": "02",              // 就诊凭证类型(必填)
      "mdtrt_cert_no": "430281199001010001", // 就诊凭证编号(必填)
      "card_sn": "",                        // 卡识别码(凭证类型为03时必填)
      "begntime": "",                       // 开始时间(获取历史参保信息时填写)
      "psn_cert_type": "01",                // 人员证件类型(必填)
      "certno": "430281199001010001",       // 证件号码(必填)
      "psn_name": "张三"                    // 人员姓名(必填)
    }
  }
}
```

#### 4.1.3 输入字段说明

| 字段名 | 类型 | 长度 | 必填 | 代码标识 | 说明 |
|--------|------|------|------|----------|------|
| mdtrt_cert_type | 字符型 | 3 | Y | Y | 就诊凭证类型：01-电子凭证；02-身份证；03-社保卡 |
| mdtrt_cert_no | 字符型 | 50 | Y | - | 就诊凭证编号 |
| card_sn | 字符型 | 32 | N | - | 卡识别码，凭证类型为03时必填 |
| begntime | 日期时间型 | - | N | - | 开始时间，获取历史参保信息时传入 |
| psn_cert_type | 字符型 | 6 | Y | Y | 人员证件类型：01-身份证 |
| certno | 字符型 | 50 | Y | - | 证件号码 |
| psn_name | 字符型 | 50 | Y | - | 人员姓名 |

#### 4.1.4 输出结构
```json
{
  "output": {
    "baseinfo": {                         // 基本信息(单条记录)
      "psn_no": "43000030281000120001",    // 人员编号
      "psn_cert_type": "01",              // 人员证件类型
      "certno": "430281199001010001",     // 证件号码
      "psn_name": "张三",                 // 人员姓名
      "gend": "1",                        // 性别：1-男，2-女
      "naty": "01",                       // 民族代码
      "brdy": "1990-01-01",               // 出生日期
      "age": 35.5,                        // 年龄
      "exp_content": ""                   // 字段扩展
    },
    "insuinfo": [                         // 参保信息(多条记录)
      {
        "balc": 1500.00,                  // 余额
        "insutype": "310",                // 险种类型
        "psn_type": "11",                 // 人员类别
        "psn_insu_stas": "1",             // 人员参保状态
        "psn_insu_date": "2010-01-01",    // 个人参保日期
        "paus_insu_date": null,           // 暂停参保日期
        "cvlserv_flag": "0",              // 公务员标志
        "insuplc_admdvs": "431199",       // 参保地医保区划
        "emp_name": "某某公司"             // 单位名称
      }
    ],
    "idetinfo": [                         // 身份信息(多条记录)
      {
        "psn_idet_type": "1",             // 人员身份类别
        "psn_type_lv": "1",               // 人员类别等级
        "memo": "",                       // 备注
        "begntime": "2010-01-01 00:00:00", // 开始时间
        "endtime": "2099-12-31 23:59:59"  // 结束时间
      }
    ]
  }
}
```

#### 4.1.5 代码字典

**就诊凭证类型(mdtrt_cert_type)**
- 01：电子凭证
- 02：身份证
- 03：社保卡

**人员证件类型(psn_cert_type)**
- 01：身份证
- 02：军官证
- 03：护照
- 99：其他

**性别(gend)**
- 1：男
- 2：女
- 9：未知

### 4.2 西药中成药目录下载接口 (1301，只查询文件名不直接下载)

#### 4.2.1 接口用途
下载最新的西药和中成药目录信息，支持基于版本号的增量更新。

#### 4.2.2 输入参数 (节点标识：data)
```json
{
  "input": {
    "data": {
      "ver": "1.0.0"                      // 版本号(必填)
    }
  }
}
```

#### 4.2.3 输入字段说明

| 字段名 | 类型 | 长度 | 必填 | 说明 |
|--------|------|------|------|------|
| ver | 字符型 | 20 | Y | 本地最大版本号，用于获取增量数据 |

#### 4.2.4 输出结构
```json
{
  "output": {
    "file_qury_no": "FQ20250714001",      // 文件查询号
    "filename": "1301_20250714.zip",      // 文件名，以供9102文件下载接口调用
    "dld_end_time": "2025-07-15",         // 下载截止日期
    "data_cnt": 15000                     // 数据量
  }
}
```

#### 4.2.5 文件格式说明

**文件结构**：
- 压缩格式：ZIP
- 内容格式：TXT文本文件
- 字段分隔：TAB制表符
- 字符编码：UTF-8
- 字段数量：97个字段

**字段定义（前20个重要字段）**：
1. 医疗目录编码
2. 药品商品名
3. 通用名编号
4. 药品通用名
5. 化学名称
6. 别名
7. 英文名称
8. 注册名称
9. 药监本位码
10. 药品剂型
11. 药品剂型名称
12. 药品类别
13. 药品类别名称
14. 药品规格
15. 药品规格代码
16. 注册剂型
17. 注册规格
18. 注册规格代码
19. 每次用量
20. 使用频次

### 4.3 文件上传接口 (9101)

#### 4.3.1 接口用途
上传医疗数据文件到医保系统，支持ZIP压缩的TXT文件格式。

#### 4.3.2 输入参数 (节点标识：fsUploadIn)
```http
POST /fsi/api/rsfComIfsService/callService HTTP/1.1
Content-Type: multipart/form-data; boundary=----WebKitFormBoundary

------WebKitFormBoundary
Content-Disposition: form-data; name="jsonStr"

{JSON报文内容}
------WebKitFormBoundary
Content-Disposition: form-data; name="file"; filename="upload.zip"
Content-Type: application/zip

{二进制文件内容}
------WebKitFormBoundary--
```

#### 4.3.3 输入字段说明

| 字段名 | 类型 | 长度 | 必填 | 说明 |
|--------|------|------|------|------|
| in | 字节数组 | - | Y | 文件数据（二进制） |
| filename | 字符型 | 200 | Y | 文件名 |
| fixmedins_code | 字符型 | 30 | Y | 医药机构编号 |

#### 4.3.4 输出结构
```json
{
  "output": {
    "file_qury_no": "UP20250714001",      // 文件查询号
    "filename": "upload.zip",             // 文件名
    "fixmedins_code": "H43111100255",     // 医药机构编号
    "dld_endtime": "2025-07-15 23:59:59"  // 截止时间
  }
}
```

### 4.4 文件下载接口 (9102)

#### 4.4.1 接口用途
下载通过目录查询接口（1301-1319等）生成的文件。

#### 4.4.2 输入参数 (节点标识：fsDownloadIn)
```json
{
  "input": {
    "fsDownloadIn": {
      "file_qury_no": "FQ20250714001",    // 文件查询号(必填)
      "filename": "1301_20250714.zip",    // 文件名(必填)
      "fixmedins_code": "plc"             // 机构编号(必填)
    }
  }
}
```

#### 4.4.3 输入字段说明

| 字段名 | 类型 | 长度 | 必填 | 说明 |
|--------|------|------|------|------|
| file_qury_no | 字符型 | 30 | Y | 文件查询号，从目录查询接口获取 |
| filename | 字符型 | 200 | Y | 文件名，从目录查询接口获取 |
| fixmedins_code | 字符型 | 30 | Y | 机构编号，目录文件固定传"plc" |

#### 4.4.4 输出格式
**响应头**：
```http
HTTP/1.1 200 OK
Content-Type: application/octet-stream
Content-Disposition: attachment; filename="1301_20250714.zip"
Content-Length: 1048576
```

**响应体**：二进制文件流

## 五、数据格式规范

### 5.1 时间格式规范

#### 5.1.1 时间格式定义
```python
TIME_FORMATS = {
    "date": "yyyy-MM-dd",                 # 日期：2025-07-14
    "datetime": "yyyy-MM-dd HH:mm:ss",    # 日期时间：2025-07-14 10:30:15
    "timestamp": "yyyyMMddHHmmss",        # 时间戳：20250714103015
    "timestamp_ms": "yyyyMMddHHmmssSSS",  # 毫秒时间戳：20250714103015123
    "msgid_time": "yyyyMMddHHmmss",       # 报文ID时间：20250714103015
    "api_timestamp": 13,                  # API时间戳：1721789415123(13位毫秒)
}
```

#### 5.1.2 时间范围查询
- 输入格式：yyyy-MM-dd
- 时间范围：开始于00:00:00，结束于23:59:59
- 示例：2025-07-14～2025-07-15 表示 2025-07-14 00:00:00～2025-07-15 23:59:59

### 5.2 数据类型规范

#### 5.2.1 空值处理
```python
NULL_VALUE_RULES = {
    "数值型": "0",        # 数值类型为空时传"0"
    "字符型": "",         # 字符类型为空时传空串""
    "TXT文件": "null",    # TXT文件中空值使用"null"
    "JSON": null,        # JSON中使用null
}
```

#### 5.2.2 特殊字符转义
```python
ESCAPE_RULES = {
    '"': '\\"',          # 双引号转义为\"
    '\\': '\\\\',        # 反斜杠转义为\\\\
}

def escape_json_string(text: str) -> str:
    """JSON字符串转义处理"""
    return text.replace('\\', '\\\\').replace('"', '\\"')
```

### 5.3 报文ID生成规范

#### 5.3.1 生成规则
```python
def generate_msgid(fixmedins_code: str) -> str:
    """
    生成30位报文ID
    
    格式：定点医药机构编号(12) + 时间(14) + 顺序号(4)
    示例：H43111100255 + 20250714103015 + 4001 = H4311110025520250714103015001
    """
    from datetime import datetime
    
    # 机构编号（12位）
    institution_code = fixmedins_code.ljust(12, '0')[:12]
    
    # 时间（14位）：yyyyMMddHHmmss
    time_str = datetime.now().strftime('%Y%m%d%H%M%S')
    
    # 顺序号（4位）：使用微秒生成
    sequence = str(int(datetime.now().microsecond / 1000)).zfill(4)
    
    return f"{institution_code}{time_str}{sequence}"

# 生成示例
msgid = generate_msgid("H43111100255")
# 结果：H4311110025520250714103015001
```

#### 5.3.2 唯一性保证
```python
class MsgIdGenerator:
    def __init__(self):
        self._last_timestamp = 0
        self._sequence = 0
    
    def generate(self, fixmedins_code: str) -> str:
        """生成唯一报文ID，避免重复"""
        current_timestamp = int(datetime.now().timestamp())
        
        if current_timestamp == self._last_timestamp:
            self._sequence += 1
        else:
            self._sequence = 1
            self._last_timestamp = current_timestamp
        
        institution_code = fixmedins_code.ljust(12, '0')[:12]
        time_str = datetime.now().strftime('%Y%m%d%H%M%S')
        sequence = str(self._sequence).zfill(4)
        
        return f"{institution_code}{time_str}{sequence}"
```

## 六、错误处理协议

### 6.1 医保接口错误码

#### 6.1.1 标准错误响应
```json
{
  "infcode": -1,
  "inf_refmsgid": null,
  "refmsg_time": null,
  "respond_time": null,
  "err_msg": "具体错误信息",
  "output": null
}
```

#### 6.1.2 常见错误类型
```python
MEDICAL_INSURANCE_ERRORS = {
    # 认证相关错误
    "INVALID_AK": "AK密钥无效",
    "SIGNATURE_MISMATCH": "签名不匹配",
    "TIMESTAMP_EXPIRED": "时间戳过期",
    
    # 参数相关错误
    "MISSING_REQUIRED_FIELD": "缺少必需字段",
    "INVALID_FIELD_FORMAT": "字段格式错误",
    "FIELD_LENGTH_EXCEEDED": "字段长度超限",
    
    # 业务相关错误
    "PERSON_NOT_FOUND": "人员信息不存在",
    "INVALID_CERT_TYPE": "证件类型无效",
    "INSURANCE_EXPIRED": "医保已过期",
    
    # 文件相关错误
    "FILE_NOT_FOUND": "文件不存在",
    "FILE_EXPIRED": "文件已过期",
    "INVALID_FILE_FORMAT": "文件格式无效",
    
    # 系统相关错误
    "SYSTEM_BUSY": "系统繁忙",
    "DATABASE_ERROR": "数据库错误",
    "NETWORK_TIMEOUT": "网络超时"
}
```

### 6.2 错误处理策略

#### 6.2.1 重试策略
```python
class RetryStrategy:
    def __init__(self):
        self.max_retries = 3
        self.retry_delay = [1, 2, 4]  # 秒
        self.retryable_errors = [
            "SYSTEM_BUSY",
            "NETWORK_TIMEOUT", 
            "DATABASE_ERROR"
        ]
    
    def should_retry(self, error_code: str, attempt: int) -> bool:
        """判断是否应该重试"""
        return (error_code in self.retryable_errors and 
                attempt < self.max_retries)
    
    def get_retry_delay(self, attempt: int) -> int:
        """获取重试延迟时间"""
        return self.retry_delay[min(attempt, len(self.retry_delay) - 1)]
```

#### 6.2.2 错误恢复机制
```python
class ErrorRecovery:
    @staticmethod
    def handle_authentication_error():
        """处理认证错误"""
        # 1. 检查AK/SK配置
        # 2. 重新生成签名
        # 3. 检查时间戳
        pass
    
    @staticmethod
    def handle_file_error(error_msg: str):
        """处理文件相关错误"""
        if "文件不存在" in error_msg:
            # 重新获取文件查询号
            pass
        elif "文件已过期" in error_msg:
            # 重新调用目录查询接口
            pass
    
    @staticmethod
    def handle_business_error(error_msg: str):
        """处理业务错误"""
        if "人员信息不存在" in error_msg:
            # 检查输入参数
            pass
        elif "医保已过期" in error_msg:
            # 提示用户更新医保信息
            pass
```

## 七、完整调用示例

### 7.1 Python完整实现

#### 7.1.1 完整的医保接口客户端
```python
import json
import time
import hmac
import hashlib
import base64
import requests
from datetime import datetime
from typing import Dict, Any, Optional

class MedicalInsuranceClient:
    def __init__(self, config: Dict[str, str]):
        """
        初始化医保接口客户端
        
        Args:
            config: 配置字典，包含以下键：
                - base_url: 医保接口基础URL
                - ak: 访问密钥
                - sk: 安全密钥
                - fixmedins_code: 机构编号
                - fixmedins_name: 机构名称
                - mdtrtarea_admvs: 医保区划
                - opter: 经办人
                - opter_name: 经办人姓名
        """
        self.config = config
        self.session = requests.Session()
        self.session.timeout = 30
    
    def generate_signature(self, api_name: str, api_version: str, timestamp: int) -> str:
        """生成API签名"""
        params = {
            '_api_access_key': self.config['ak'],
            '_api_name': api_name,
            '_api_timestamp': str(timestamp),
            '_api_version': api_version
        }
        
        sign_string = '&'.join([f"{k}={v}" for k, v in sorted(params.items())])
        
        signature = hmac.new(
            self.config['sk'].encode('utf-8'),
            sign_string.encode('utf-8'),
            hashlib.sha1
        ).digest()
        
        return base64.b64encode(signature).decode('utf-8')
    
    def generate_msgid(self) -> str:
        """生成报文ID"""
        now = datetime.now()
        time_str = now.strftime('%Y%m%d%H%M%S')
        sequence = str(int(now.microsecond / 1000)).zfill(4)
        return f"{self.config['fixmedins_code']}{time_str}{sequence}"
    
    def build_base_request(self, infno: str, input_data: Dict[str, Any]) -> Dict[str, Any]:
        """构建基础请求报文"""
        return {
            "infno": infno,
            "msgid": self.generate_msgid(),
            "mdtrtarea_admvs": self.config['mdtrtarea_admvs'],
            "insuplc_admdvs": self.config.get('insuplc_admdvs', self.config['mdtrtarea_admvs']),
            "recer_sys_code": "99",
            "dev_no": "null",
            "dev_safe_info": "null",
            "cainfo": "null",
            "signtype": "SM2",
            "infver": "1.0.0",
            "opter_type": "1",
            "opter": self.config['opter'],
            "opter_name": self.config['opter_name'],
            "inf_time": datetime.now().strftime('%Y-%m-%d %H:%M:%S'),
            "fixmedins_code": self.config['fixmedins_code'],
            "fixmedins_name": self.config['fixmedins_name'],
            "sign_no": "null",
            "input": input_data
        }
    
    def call_api(self, api_name: str, request_data: Dict[str, Any], 
                 is_file_download: bool = False) -> Dict[str, Any]:
        """调用医保接口"""
        # 生成时间戳和签名
        timestamp = int(time.time() * 1000)
        signature = self.generate_signature(api_name, "1.0.0", timestamp)
        
        # 设置请求头
        headers = {
            '_api_name': api_name,
            '_api_version': '1.0.0',
            '_api_timestamp': str(timestamp),
            '_api_access_key': self.config['ak'],
            '_api_signature': signature,
            'Content-Type': 'text/plain; charset=utf-8'
        }
        
        # 发送请求
        response = self.session.post(
            self.config['base_url'],
            data=json.dumps(request_data, ensure_ascii=False).encode('utf-8'),
            headers=headers
        )
        
        if response.status_code != 200:
            raise Exception(f"HTTP错误: {response.status_code}")
        
        # 处理文件下载
        if is_file_download:
            content_type = response.headers.get('Content-Type', '')
            if 'application/octet-stream' in content_type:
                return {
                    'success': True,
                    'data': response.content,
                    'is_file': True
                }
        
        # 处理JSON响应
        try:
            result = response.json()
            return {
                'success': result.get('infcode') == 0,
                'data': result,
                'error': result.get('err_msg') if result.get('infcode') != 0 else None
            }
        except json.JSONDecodeError:
            raise Exception(f"响应格式错误: {response.text}")
    
    def query_patient(self, cert_type: str, cert_no: str, name: str = "") -> Dict[str, Any]:
        """查询患者信息"""
        input_data = {
            "data": {
                "mdtrt_cert_type": cert_type,
                "mdtrt_cert_no": cert_no,
                "card_sn": "",
                "begntime": "",
                "psn_cert_type": "01",
                "certno": cert_no,
                "psn_name": name
            }
        }
        
        request_data = self.build_base_request("1101", input_data)
        return self.call_api("1101", request_data)
    
    def get_drug_catalog_info(self, version: str = "1.0.0") -> Dict[str, Any]:
        """获取药品目录文件信息"""
        input_data = {
            "data": {
                "ver": version
            }
        }
        
        request_data = self.build_base_request("1301", input_data)
        return self.call_api("1301", request_data)
    
    def download_file(self, file_query_no: str, filename: str, 
                     fixmedins_code: str = "plc") -> Dict[str, Any]:
        """下载文件"""
        input_data = {
            "fsDownloadIn": {
                "file_qury_no": file_query_no,
                "filename": filename,
                "fixmedins_code": fixmedins_code
            }
        }
        
        request_data = self.build_base_request("9102", input_data)
        return self.call_api("9102", request_data, is_file_download=True)
```

#### 7.1.2 使用示例
```python
# 1. 初始化客户端
config = {
    'base_url': 'https://dms.hun.hsip.gov.cn/fsi/api/rsfComIfsService/callService',
    'ak': 'your_access_key',
    'sk': 'your_secret_key',
    'fixmedins_code': 'H43111100255',
    'fixmedins_name': '某某医院',
    'mdtrtarea_admvs': '431199',
    'opter': '0153',
    'opter_name': '系统管理员'
}

client = MedicalInsuranceClient(config)

# 2. 查询患者信息
try:
    result = client.query_patient("02", "430281199001010001", "张三")
    if result['success']:
        baseinfo = result['data']['output']['baseinfo']
        print(f"患者姓名: {baseinfo['psn_name']}")
        print(f"人员编号: {baseinfo['psn_no']}")
        
        insuinfo = result['data']['output']['insuinfo']
        if insuinfo:
            print(f"医保余额: {insuinfo[0]['balc']}")
    else:
        print(f"查询失败: {result['error']}")
        
except Exception as e:
    print(f"调用异常: {e}")

# 3. 下载药品目录
try:
    # 获取文件信息
    file_info = client.get_drug_catalog_info("1.0.0")
    if file_info['success']:
        output = file_info['data']['output']
        file_query_no = output['file_qury_no']
        filename = output['filename']
        
        # 下载文件
        download_result = client.download_file(file_query_no, filename, "plc")
        if download_result['success'] and download_result.get('is_file'):
            with open(f"downloads/{filename}", "wb") as f:
                f.write(download_result['data'])
            print(f"文件下载成功: {filename}")
        else:
            print("文件下载失败")
    else:
        print(f"获取文件信息失败: {file_info['error']}")
        
except Exception as e:
    print(f"下载异常: {e}")
```

### 7.2 Java完整实现

#### 7.2.1 Java客户端示例
```java
import org.apache.http.HttpEntity;
import org.apache.http.client.methods.CloseableHttpResponse;
import org.apache.http.client.methods.HttpPost;
import org.apache.http.entity.StringEntity;
import org.apache.http.impl.client.CloseableHttpClient;
import org.apache.http.impl.client.HttpClients;
import org.apache.http.util.EntityUtils;

import javax.crypto.Mac;
import javax.crypto.spec.SecretKeySpec;
import java.nio.charset.StandardCharsets;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.Base64;
import java.util.HashMap;
import java.util.Map;
import java.util.TreeMap;

public class MedicalInsuranceClient {
    
    private final String baseUrl;
    private final String accessKey;
    private final String secretKey;
    private final String fixmedinsCode;
    private final String fixmedinsName;
    private final String mdtrtareaAdmvs;
    private final String opter;
    private final String opterName;
    
    public MedicalInsuranceClient(Map<String, String> config) {
        this.baseUrl = config.get("baseUrl");
        this.accessKey = config.get("accessKey");
        this.secretKey = config.get("secretKey");
        this.fixmedinsCode = config.get("fixmedinsCode");
        this.fixmedinsName = config.get("fixmedinsName");
        this.mdtrtareaAdmvs = config.get("mdtrtareaAdmvs");
        this.opter = config.get("opter");
        this.opterName = config.get("opterName");
    }
    
    public String generateSignature(String apiName, String apiVersion, long timestamp) throws Exception {
        Map<String, String> params = new TreeMap<>();
        params.put("_api_access_key", accessKey);
        params.put("_api_name", apiName);
        params.put("_api_timestamp", String.valueOf(timestamp));
        params.put("_api_version", apiVersion);
        
        StringBuilder signString = new StringBuilder();
        for (Map.Entry<String, String> entry : params.entrySet()) {
            if (signString.length() > 0) {
                signString.append("&");
            }
            signString.append(entry.getKey()).append("=").append(entry.getValue());
        }
        
        Mac mac = Mac.getInstance("HmacSHA1");
        SecretKeySpec secretKeySpec = new SecretKeySpec(secretKey.getBytes(StandardCharsets.UTF_8), "HmacSHA1");
        mac.init(secretKeySpec);
        byte[] signature = mac.doFinal(signString.toString().getBytes(StandardCharsets.UTF_8));
        
        return Base64.getEncoder().encodeToString(signature);
    }
    
    public String generateMsgId() {
        LocalDateTime now = LocalDateTime.now();
        String timeStr = now.format(DateTimeFormatter.ofPattern("yyyyMMddHHmmss"));
        String sequence = String.format("%04d", now.getNano() / 1000000);
        return fixmedinsCode + timeStr + sequence;
    }
    
    public Map<String, Object> buildBaseRequest(String infno, Map<String, Object> inputData) {
        Map<String, Object> request = new HashMap<>();
        request.put("infno", infno);
        request.put("msgid", generateMsgId());
        request.put("mdtrtarea_admvs", mdtrtareaAdmvs);
        request.put("insuplc_admdvs", mdtrtareaAdmvs);
        request.put("recer_sys_code", "99");
        request.put("dev_no", "null");
        request.put("dev_safe_info", "null");
        request.put("cainfo", "null");
        request.put("signtype", "SM2");
        request.put("infver", "1.0.0");
        request.put("opter_type", "1");
        request.put("opter", opter);
        request.put("opter_name", opterName);
        request.put("inf_time", LocalDateTime.now().format(DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss")));
        request.put("fixmedins_code", fixmedinsCode);
        request.put("fixmedins_name", fixmedinsName);
        request.put("sign_no", "null");
        request.put("input", inputData);
        
        return request;
    }
    
    public String callApi(String apiName, Map<String, Object> requestData) throws Exception {
        long timestamp = System.currentTimeMillis();
        String signature = generateSignature(apiName, "1.0.0", timestamp);
        
        CloseableHttpClient httpClient = HttpClients.createDefault();
        HttpPost httpPost = new HttpPost(baseUrl);
        
        // 设置请求头
        httpPost.setHeader("_api_name", apiName);
        httpPost.setHeader("_api_version", "1.0.0");
        httpPost.setHeader("_api_timestamp", String.valueOf(timestamp));
        httpPost.setHeader("_api_access_key", accessKey);
        httpPost.setHeader("_api_signature", signature);
        httpPost.setHeader("Content-Type", "text/plain; charset=utf-8");
        
        // 设置请求体
        String jsonData = new ObjectMapper().writeValueAsString(requestData);
        httpPost.setEntity(new StringEntity(jsonData, StandardCharsets.UTF_8));
        
        // 发送请求
        CloseableHttpResponse response = httpClient.execute(httpPost);
        try {
            HttpEntity entity = response.getEntity();
            return EntityUtils.toString(entity, StandardCharsets.UTF_8);
        } finally {
            response.close();
            httpClient.close();
        }
    }
    
    // 使用示例
    public static void main(String[] args) throws Exception {
        Map<String, String> config = new HashMap<>();
        config.put("baseUrl", "https://dms.hun.hsip.gov.cn/fsi/api/rsfComIfsService/callService");
        config.put("accessKey", "your_access_key");
        config.put("secretKey", "your_secret_key");
        config.put("fixmedinsCode", "H43111100255");
        config.put("fixmedinsName", "某某医院");
        config.put("mdtrtareaAdmvs", "431199");
        config.put("opter", "0153");
        config.put("opterName", "系统管理员");
        
        MedicalInsuranceClient client = new MedicalInsuranceClient(config);
        
        // 查询患者信息
        Map<String, Object> inputData = new HashMap<>();
        Map<String, Object> data = new HashMap<>();
        data.put("mdtrt_cert_type", "02");
        data.put("mdtrt_cert_no", "430281199001010001");
        data.put("card_sn", "");
        data.put("begntime", "");
        data.put("psn_cert_type", "01");
        data.put("certno", "430281199001010001");
        data.put("psn_name", "张三");
        inputData.put("data", data);
        
        Map<String, Object> request = client.buildBaseRequest("1101", inputData);
        String result = client.callApi("1101", request);
        
        System.out.println("查询结果: " + result);
    }
}
```

## 八、测试环境配置

### 8.1 环境配置
```python
# 生产环境配置
PRODUCTION_CONFIG = {
    'base_url': 'https://dms.hun.hsip.gov.cn/fsi/api/rsfComIfsService/callService',
    'ak': 'yRV6rnHYEa2clmx1MCWb4HjlOcwhS8gLbW6O4o',
    'sk': 'SK8Z8G7jSm2023T1jn6EgRweJ0Fy1JpeielmJnBe'
}

# 测试环境配置
TEST_CONFIG = {
    'base_url': 'https://test_dms.hun.hsip.gov.cn/fsi/api/rsfComIfsService/callService',
    'ak': 'QAzP6NM9LqAFoXtNOoct53MU1GHlScXhhV5nme',
    'sk': 'SKQRDvd69HJkGXAobkFMYv9yiuTxDEHeZ0ILHgfd'
}

# 电子凭证环境
ELECTRONIC_VOUCHER_CONFIG = {
    'base_url': 'https://dvs.hun.hsip.gov.cn/fsi/api/rsfComIfsService/callService'
}
```

### 8.2 机构配置示例
```python
# 醴陵远恒医院配置
LILIN_HOSPITAL_CONFIG = {
    'fixmedins_code': 'H43028100255',
    'fixmedins_name': '醴陵远恒医院(有限合伙)',
    'mdtrtarea_admvs': '430299',
    'insuplc_admdvs': '430299',
    'opter': '0053',
    'opter_name': '系统管理员'
}

# 湘潭糖尿病医院配置
XIANGTAN_HOSPITAL_CONFIG = {
    'fixmedins_code': 'H43030400120',
    'fixmedins_name': '湘潭糖尿病医院',
    'mdtrtarea_admvs': '430399',
    'insuplc_admdvs': '430304',
    'opter': '',
    'opter_name': ''
}
```

这份详细的医保接口协议文档基于官方规范，包含了完整的技术实现细节，可以作为开发团队的权威参考文档。